context = [
    {
        "sourceCode": '\nCREATE TABLE IF NOT EXISTS "auth_accounts" (\n\t"userId" text NOT NULL,\n\t"type" text NOT NULL,\n\t"provider" text NOT NULL,\n\t"providerAccountId" text NOT NULL,\n\t"refresh_token" text,\n\t"access_token" text,\n\t"expires_at" integer,\n\t"token_type" text,\n\t"scope" text,\n\t"id_token" text,\n\t"session_state" text,\n\tCONSTRAINT "auth_accounts_provider_providerAccountId_pk" PRIMARY KEY("provider","providerAccountId")\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS "auth_sessions" (\n\t"sessionToken" text PRIMARY KEY NOT NULL,\n\t"userId" text NOT NULL,\n\t"expires" timestamp NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE IF NOT EXISTS "verification_tokens" (\n\t"identifier" text NOT NULL,\n\t"token" text NOT NULL,\n\t"expires" timestamp NOT NULL,\n\tCONSTRAINT "verification_tokens_identifier_token_pk" PRIMARY KEY("identifier","token")\n);\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE "auth_accounts" ADD CONSTRAINT "auth_accounts_userId_users_id_fk" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n--> statement-breakpoint\nDO $$ BEGIN\n ALTER TABLE "auth_sessions" ADD CONSTRAINT "auth_sessions_userId_users_id_fk" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE cascade ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;',
        "fileName": "/drizzle/0001_giant_tattoo.sql",
        "summary": 'This SQL file creates and configures tables for user authentication and session management. It establishes three tables: "auth_accounts" for storing user account details, "auth_sessions" for managing active sessions, and "verification_tokens" for handling token-based verification. The file also sets up foreign key relationships between these tables and a presumed "users" table. This structure supports a robust authentication system, allowing for multiple account types, session tracking, and secure user verification processes.',
        "similarity": 0.693287260985013,
    },
    {
        "sourceCode": '\nimport NextAuth from "next-auth";\nimport { authOptions } from "./auth";\n\nconst handler = NextAuth(authOptions);\n\nexport { handler as GET, handler as POST };',
        "fileName": "/app/api/auth/[...nextauth]/route.ts",
        "summary": "This file configures and exports the authentication handler for the application using NextAuth.js. It imports the authentication options from a separate file and creates a handler using NextAuth with these options. The handler is then exported for both GET and POST requests, enabling authentication functionality for various routes in the application. This setup centralizes the authentication logic and makes it available for use throughout the project.",
        "similarity": 0.6859822287284232,
    },
    {
        "sourceCode": '\nimport bcrypt from "bcryptjs";\nimport { eq } from "drizzle-orm";\nimport { db } from "@/db/drizzle";\nimport { AuthOptions } from "next-auth";\nimport { usersTable } from "@/db/schema";\nimport { DrizzleAdapter } from "@auth/drizzle-adapter";\nimport CredentialsProvider from "next-auth/providers/credentials";\n\nexport const authOptions: AuthOptions = {\n  adapter: DrizzleAdapter(db) as any,\n  providers: [\n    CredentialsProvider({\n      name: "credentials",\n      credentials: {\n        email: { label: "Email", type: "text" },\n        password: { label: "Password", type: "password" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email) {\n          throw new Error("Email is required");\n        }\n        if (!credentials?.password) {\n          throw new Error("Password is required");\n        }\n\n        const [user] = await db\n          .select()\n          .from(usersTable)\n          .where(eq(usersTable.email, credentials.email));\n\n        if (!user) {\n          throw new Error("Invalid email");\n        }\n\n        const isPasswordValid = await bcrypt.compare(\n          credentials.password,\n          user.password!\n        );\n\n        if (!isPasswordValid) {\n          throw new Error("Invalid password");\n        }\n        return user;\n      },\n    }),\n  ],\n  session: {\n    strategy: "jwt",\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  callbacks: {\n    async signIn({ user, account }) {\n      try {\n        console.log("User", user);\n        console.log("Account", account);\n        const existingUsers = await db\n          .select()\n          .from(usersTable)\n          .where(eq(usersTable.email, user.email!))\n          .limit(1);\n\n        return true;\n      } catch (error) {\n        console.error("Error in signIn callback:", error);\n        return false;\n      }\n    },\n  },\n};',
        "fileName": "/app/api/auth/[...nextauth]/auth.ts",
        "summary": "This file configures authentication options for NextAuth in a Next.js application. It sets up a credentials provider for email/password authentication, using Drizzle ORM for database operations. The file defines the authorization process, including email and password validation, user lookup, and password comparison. It also configures JWT session strategy and includes a signIn callback to check for existing users. The setup uses bcrypt for password hashing and comparison, ensuring secure authentication. This file is crucial for managing user authentication and session handling in the application.",
        "similarity": 0.6780862210531795,
    },
    {
        "sourceCode": '\n"use client";\nimport { SessionProvider } from "next-auth/react";\n\nconst NextAuthProvider = ({ children }: { children: React.ReactNode }) => {\n  return <SessionProvider>{children}</SessionProvider>;\n};\n\nexport default NextAuthProvider;',
        "fileName": "/app/provider.tsx",
        "summary": "This file defines a NextAuthProvider component, which wraps the application with Next.js authentication functionality. It uses the SessionProvider from next-auth/react to manage user sessions across the app. The component takes children as a prop, allowing it to encompass other components and provide them with authentication context. This setup enables seamless integration of authentication features throughout the application, making it easier to handle user sessions and protected routes.",
        "similarity": 0.657152513164952,
    },
    {
        "sourceCode": '\nimport bcrypt from "bcryptjs";\nimport { eq } from "drizzle-orm";\nimport { db } from "@/db/drizzle";\nimport { usersTable } from "@/db/schema";\nimport { NextResponse } from "next/server";\n\nexport async function POST(request: Request) {\n  try {\n    const { name, email, password } = await request.json();\n\n    const existingUser = await db\n      .select()\n      .from(usersTable)\n      .where(eq(usersTable.email, email))\n      .limit(1);\n\n    if (existingUser.length > 0) {\n      return NextResponse.json(\n        { error: "User already exists" },\n        { status: 400 }\n      );\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    const [user] = await db\n      .insert(usersTable)\n      .values({\n        name,\n        email,\n        password: hashedPassword,\n      })\n      .returning();\n\n    return NextResponse.json(\n      { message: "User created  successfully. Please Login." },\n      { status: 201 }\n    );\n  } catch (error) {\n    console.error("SIGNUP[POST]:", error);\n    return NextResponse.json(\n      { error: "Internal Server Error" },\n      { status: 500 }\n    );\n  }\n}',
        "fileName": "/app/api/users/signup/route.ts",
        "summary": "This file handles user signup functionality. It defines a POST route that:\n\n1. Receives user data (name, email, password)\n2. Checks if the user already exists\n3. If not, hashes the password\n4. Creates a new user in the database\n5. Returns appropriate responses\n\nThe code uses bcrypt for password hashing, Drizzle ORM for database operations, and Next.js server-side components. It includes error handling for existing users and internal server errors, ensuring secure and robust user registration.",
        "similarity": 0.6408069616154237,
    },
    {
        "sourceCode": '\n"use client";\n\nimport { Button } from "@/components/ui/button";\nimport { SubmitHandler, useForm } from "react-hook-form";\nimport { z } from "zod";\nimport { zodResolver } from "@hookform/resolvers/zod";\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from "@/components/ui/form";\nimport { Input } from "@/components/ui/input";\nimport Link from "next/link";\nimport { signIn } from "next-auth/react";\nimport { useRouter } from "next/navigation";\nimport toast from "react-hot-toast";\nimport { useState } from "react";\n\nconst AuthForm = () => {\n  const router = useRouter();\n  const [isLoading, setIsLoading] = useState(false);\n\n  const formSchema = z.object({\n    email: z.string().email(),\n    password: z.string().min(6),\n  });\n\n  type FormValues = z.infer<typeof formSchema>;\n\n  const form = useForm<FormValues>({\n    defaultValues: {\n      email: "",\n      password: "",\n    },\n    resolver: zodResolver(formSchema),\n  });\n\n  const onSubmit: SubmitHandler<FormValues> = async (data) => {\n    setIsLoading(true);\n    try {\n      const result = await signIn("credentials", {\n        redirect: false,\n        email: data.email,\n        password: data.password,\n      });\n\n      if (result?.error) {\n        console.error("Sign-in error:", result.error);\n        toast.error("Invalid Credentials");\n      } else {\n        toast.success("Login Successfully");\n        router.push("/");\n      }\n    } catch (error) {\n      console.error("An unexpected error occurred:", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className="border rounded-lg p-7 mt-5 max-w-[550px] mx-3 shadow-xl w-full">\n      <Form {...form}>\n        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-5">\n          <FormField\n            control={form.control}\n            name="email"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Email</FormLabel>\n                <FormControl>\n                  <Input\n                    disabled={isLoading}\n                    placeholder="Enter Your Email"\n                    {...field}\n                  />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={form.control}\n            name="password"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Password</FormLabel>\n                <FormControl>\n                  <Input\n                    disabled={isLoading}\n                    type="password"\n                    placeholder="Enter Your Password"\n                    {...field}\n                  />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <Button type="submit" disabled={isLoading} className="w-full">\n            Sign In\n          </Button>\n        </form>\n      </Form>\n      <div className="mt-4">\n        <p className="text-center">\n          New Here?{" "}\n          <Link href={"/sign-up"} className="font-medium underline">\n            Create An Account\n          </Link>{" "}\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default AuthForm;',
        "fileName": "/app/(auth)/sign-in/components/auth-form.tsx",
        "summary": "This file contains the AuthForm component, which implements a sign-in form for user authentication. It uses React Hook Form for form handling, Zod for form validation, and Next.js for routing. The component renders input fields for email and password, handles form submission, and manages loading states. Upon successful sign-in, it redirects the user to the home page and displays a success toast. Error handling is implemented with error toasts. The component also includes a link to the sign-up page for new users. Overall, it provides a complete and user-friendly authentication interface.",
        "similarity": 0.6382642702058539,
    },
    {
        "sourceCode": '\nimport { NextRequest, NextResponse } from "next/server";\n\nexport const middleware = (req: NextRequest) => {\n  const pathname = req.nextUrl.pathname;\n\n  const isPublicPath = pathname == "/sign-in" || pathname == "/sign-up";\n\n  const nextAuthToken =\n    req.cookies.get("next-auth.session-token") ||\n    req.cookies.get("__Secure-next-auth.session-token");\n\n  if (!nextAuthToken && !isPublicPath) {\n    return NextResponse.redirect(new URL("/sign-in", req.url));\n  }\n\n  if (isPublicPath && nextAuthToken) {\n    return NextResponse.redirect(new URL("/", req.url));\n  }\n};\n\nexport const config = {\n  matcher: [\n    "/",\n    "/sign-in",\n    "/sign-up",\n    "/(dashboard)/:path*",\n    "/accounts",\n    "/categories",\n    "/transactions",\n  ],\n};',
        "fileName": "/middleware.ts",
        "summary": "This middleware file manages authentication and route protection in a Next.js application. It checks if the user is authenticated by looking for a session token in cookies. If a user is not authenticated and tries to access a protected route, they are redirected to the sign-in page. Conversely, authenticated users attempting to access public routes (sign-in or sign-up) are redirected to the home page. The config object specifies which routes this middleware should be applied to, including dashboard, accounts, categories, and transactions pages.",
        "similarity": 0.637759053030685,
    },
    {
        "sourceCode": '\nimport { authOptions } from "@/app/api/auth/[...nextauth]/auth";\nimport { getServerSession } from "next-auth";\n\nexport default async function getSession() {\n  return await getServerSession(authOptions);\n}',
        "fileName": "/actions/getSessions.ts",
        "summary": "This file defines a function `getSession` that retrieves the current server-side session using Next.js authentication. It imports necessary components from Next.js authentication system and uses `getServerSession` with predefined `authOptions`. This function is likely used throughout the application to check user authentication status and access session data on the server side, enabling secure, authenticated requests and personalized user experiences.",
        "similarity": 0.636752356206313,
    },
    {
        "sourceCode": '\n"use client";\n\nimport { useState } from "react";\nimport axios from "axios";\nimport { Button } from "@/components/ui/button";\nimport { SubmitHandler, useForm } from "react-hook-form";\nimport { BsGoogle } from "react-icons/bs";\nimport { z } from "zod";\nimport { zodResolver } from "@hookform/resolvers/zod";\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from "@/components/ui/form";\nimport { Input } from "@/components/ui/input";\nimport Link from "next/link";\nimport { useRouter } from "next/navigation";\nimport toast from "react-hot-toast";\n\ntype variant = "signup" | "verify";\n\nconst AuthForm = () => {\n  const [step, setStep] = useState<variant>("signup");\n  const [isLoading, setIsLoading] = useState(false);\n  const router = useRouter();\n\n  const signupSchema = z.object({\n    name: z.string().min(3).trim(),\n    email: z.string().email().trim(),\n    password: z\n      .string()\n      .min(6, "Password must contain at least 6 character(s)")\n      .trim(),\n  });\n\n  const otpSchema = z.object({\n    otp: z.string().length(6),\n  });\n\n  type SignupFormValues = z.infer<typeof signupSchema>;\n  type OtpFormValues = z.infer<typeof otpSchema>;\n\n  const signupForm = useForm<SignupFormValues>({\n    defaultValues: {\n      name: "",\n      email: "",\n      password: "",\n    },\n    resolver: zodResolver(signupSchema),\n  });\n\n  const otpForm = useForm<OtpFormValues>({\n    defaultValues: {\n      otp: "",\n    },\n    resolver: zodResolver(otpSchema),\n  });\n\n  const onSignupSubmit: SubmitHandler<SignupFormValues> = async (data) => {\n    setIsLoading(true);\n    try {\n      const response = await axios.post("/api/users/signup", data);\n      toast.success(response.data.message);\n      router.push("/sign-in");\n      // setStep("verify");\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        console.error("Signup error:", error.response?.data.error);\n        toast.error(error.response?.data.error || "An error occurred");\n      } else {\n        console.error("An unexpected error occurred:", error);\n        toast.error("Something went wrong");\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const onOtpSubmit: SubmitHandler<OtpFormValues> = async (data) => {\n    setIsLoading(true);\n    try {\n      const response = await axios.post("/api/users/verifyotp", {\n        email: signupForm.getValues("email"),\n        otp: data.otp,\n      });\n      if (response.status === 200) {\n        router.push("/sign-in");\n        toast.success("OTP verified successfully");\n      }\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        console.error("OTP verification error:", error.response?.data.error);\n        toast.error(error.response?.data.error || "An error occurred");\n      } else {\n        console.error("An unexpected error occurred:", error);\n        toast.error("Something went wrong");\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const resendOtp = async () => {\n    try {\n      const response = await axios.post("/api/users/resendotp", {\n        email: signupForm.getValues("email"),\n      });\n      toast.success("New OTP sent. Please check your email.");\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        console.error("OTP resend error:", error.response?.data.error);\n        toast.error(error.response?.data.error || "An error occurred");\n      } else {\n        console.error("An unexpected error occurred:", error);\n        toast.error("Something went wrong");\n      }\n    }\n  };\n\n  return (\n    <div className="border rounded-lg p-7 mt-5 max-w-[550px] mx-3 shadow-xl w-full">\n      {step === "signup" ? (\n        <>\n          <Form {...signupForm}>\n            <form\n              onSubmit={signupForm.handleSubmit(onSignupSubmit)}\n              className="space-y-5"\n            >\n              <FormField\n                control={signupForm.control}\n                name="name"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Name</FormLabel>\n                    <FormControl>\n                      <Input\n                        disabled={isLoading}\n                        placeholder="Enter Your Name"\n                        {...field}\n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              <FormField\n                control={signupForm.control}\n                name="email"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Email</FormLabel>\n                    <FormControl>\n                      <Input\n                        disabled={isLoading}\n                        placeholder="Enter Your Email"\n                        {...field}\n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              <FormField\n                control={signupForm.control}\n                name="password"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Password</FormLabel>\n                    <FormControl>\n                      <Input\n                        disabled={isLoading}\n                        type="password"\n                        placeholder="Enter Your Password"\n                        {...field}\n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              <Button type="submit" disabled={isLoading} className="w-full">\n                Sign Up\n              </Button>\n            </form>\n          </Form>\n          <div className="mt-4">\n            <p className="text-center">\n              Already Have An Account?{" "}\n              <Link href={"/sign-in"} className="font-medium underline">\n                Login Here\n              </Link>\n            </p>\n          </div>\n        </>\n      ) : (\n        <Form {...otpForm}>\n          <form\n            onSubmit={otpForm.handleSubmit(onOtpSubmit)}\n            className="space-y-5"\n          >\n            <FormField\n              control={otpForm.control}\n              name="otp"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>OTP</FormLabel>\n                  <FormControl>\n                    <Input\n                      disabled={isLoading}\n                      placeholder="Enter OTP"\n                      {...field}\n                    />\n                  </FormControl>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n            <Button type="submit" disabled={isLoading} className="w-full">\n              Verify OTP\n            </Button>\n            <Button\n              disabled={isLoading}\n              type="button"\n              variant="outline"\n              className="w-full"\n              onClick={resendOtp}\n            >\n              Resend OTP\n            </Button>\n          </form>\n        </Form>\n      )}\n    </div>\n  );\n};\n\nexport default AuthForm;',
        "fileName": "/app/(auth)/sign-up/components/auth-form.tsx",
        "summary": "This file contains a React component for user authentication, specifically for sign-up and OTP verification. It uses React Hook Form for form handling, Zod for schema validation, and Axios for API requests. The component renders either a sign-up form or an OTP verification form based on the current step. It includes form fields for name, email, and password during sign-up, and an OTP input field for verification. The component also handles form submission, error handling, and displays toast notifications for user feedback. It provides options for signing up, verifying OTP, and resending OTP if needed.",
        "similarity": 0.6346722457406511,
    },
    {
        "sourceCode": '\nimport { db } from "@/db/drizzle";\nimport getSession from "./getSessions";\nimport { usersTable } from "@/db/schema";\nimport { eq } from "drizzle-orm";\n\nconst getCurrentUser = async () => {\n  try {\n    const session = await getSession();\n\n    if (!session?.user?.email) {\n      return null;\n    }\n\n    const [user] = await db\n      .select()\n      .from(usersTable)\n      .where(eq(usersTable.email, session.user.email));\n\n    if (!user) return null;\n\n    return user;\n  } catch (error) {\n    return null;\n  }\n};\n\nexport default getCurrentUser;',
        "fileName": "/actions/getCurrentUser.ts",
        "summary": "This file defines an asynchronous function `getCurrentUser` that retrieves the current user's information from the database. It first checks for an active session using `getSession()`. If a valid session exists, it queries the database using Drizzle ORM to find a user with a matching email. The function returns the user object if found, or null if no session exists, no user is found, or an error occurs. This function is likely used for authentication and user-related operations throughout the application.",
        "similarity": 0.6131270496635504,
    },
]
